package service

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-redis/redis/v8"
	"go-admin/app/scrm"
	"go-admin/app/scrm/model"
	"go-admin/common/actions"
	"go-admin/common/gormscope"
	common "go-admin/common/models"
	"go-admin/common/util"
	"gorm.io/gorm"
	"strconv"
	"time"
)

const (
	ProjectStateStop  = 1 // 停用
	ProjectStateStart = 2 // 启用
)

type SearchProjectsReq struct {
	ProjectName  string `json:"projectName"`
	DeptName     string `json:"deptName"`
	ProjectState int    `json:"projectState"`
	Pagination
}

type ProjectResponseItem struct {
	ID         int     `json:"id"`
	Name       string  `json:"name"`
	CreatorID  int     `json:"creatorId"`
	Dept       string  `json:"dept"`
	RobotID    *int    `json:"robotId,omitempty"`
	Seats      []int   `json:"seats"`
	SpareSeatC float64 `json:"spareSeatC"`
	BusySeatC  float64 `json:"busySeatC"`
	Running    bool    `json:"running"`
}

func SearchProjects(ctx context.Context, req SearchProjectsReq) ([]ProjectResponseItem, int64, error) {
	scrm.Logger().WithContext(ctx).Info("search projects")
	var (
		projects []*model.Project
		count    int64
	)
	db := scrm.GormDB.WithContext(ctx).
		Joins("left join sys_dept on scrm_project.dept_id=sys_dept.dept_id").
		Scopes(
			actions.DeptPermission(ctx, model.Project{}.TableName()),
			gormscope.Paginate(&req.Pagination),
			SearchProjectsScope(req),
		).
		Preload("Seats").Preload("Dept").
		Order("id asc").
		Find(&projects)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("search project error", err.Error())
		return nil, 0, err
	}
	db = db.Limit(-1).Offset(-1).Count(&count)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("count project error", err.Error())
		return nil, 0, err
	}
	items := make([]ProjectResponseItem, len(projects))
	for i, project := range projects {
		items[i] = ProjectResponseItem{
			ID:        project.ID,
			Name:      project.Name,
			CreatorID: project.CreateBy,
			Dept:      project.Dept.DeptName,
			RobotID:   project.RobotID,
			Seats: func() []int {
				ret := make([]int, len(project.Seats))
				for i, seat := range project.Seats {
					ret[i] = seat.ID
				}
				return ret
			}(),
			SpareSeatC: project.SpareSeatC,
			BusySeatC:  project.BusySeatC,
			Running:    project.Running,
		}
	}
	return items, count, nil
}

func SearchProjectsScope(req SearchProjectsReq) func(db *gorm.DB) *gorm.DB {
	return func(db *gorm.DB) *gorm.DB {
		if len(req.ProjectName) > 0 {
			db = db.Where("scrm_project.name = ?", req.ProjectName)
		}
		if len(req.DeptName) > 0 {
			db = db.Where("sys_dept.dept_name = ?", req.DeptName)
		}
		switch req.ProjectState {
		case ProjectStateStop:
			db = db.Where("NOT scrm_project.running")
		case ProjectStateStart:
			db = db.Where("scrm_project.running")
		default:
		}
		return db
	}
}

type CreateProjectReq struct {
	Name    string `json:"name"`
	DeptID  int    `json:"deptId"`
	RobotID int    `json:"robotId"`
	Seats   []int  `json:"seats"`
	common.ControlBy
}

func (r CreateProjectReq) toModel() model.Project {
	seats := make([]model.Seat, 0)
	for _, v := range r.Seats {
		seats = append(seats, model.Seat{ID: v})
	}
	var robotID *int
	if r.RobotID > 0 {
		robotID = &r.RobotID
	}
	return model.Project{
		Name:    r.Name,
		DeptID:  r.DeptID,
		RobotID: robotID,
		Running: false,
		Seats:   seats,
	}
}

type CreateProjectResp struct{}

func CreateProject(ctx context.Context, req CreateProjectReq) error {
	var (
		err   error
		count int64
	)
	err = scrm.GormDB.WithContext(ctx).Model(&model.Project{}).Where("name = ?", req.Name).Count(&count).Error
	if err != nil {
		scrm.Logger().WithContext(ctx).Error("db error", err.Error())
		return err
	}
	if count > 0 {
		return errors.New("项目名已存在")
	}

	m := req.toModel()
	m.BusySeatC = 0.5
	m.SpareSeatC = 3
	db := scrm.GormDB.WithContext(ctx).Create(&m)
	if db.Error != nil {
		scrm.Logger().WithContext(ctx).Error("db error", err.Error())
		return err
	}
	return nil
}

type DeleteProjectReq struct {
	ID int `form:"id"`

	common.ControlBy
}

type DeleteProjectResp struct{}

func DeleteProject(ctx context.Context, req DeleteProjectReq) error {
	db := scrm.GormDB.WithContext(ctx).
		Scopes(
			actions.DeptPermission(ctx, model.Project{}.TableName()),
		).Delete(&model.Project{}, req.ID)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error(ctx, "Error found in delete project :", err.Error())
		return err
	}
	if db.RowsAffected == 0 {
		return errors.New("无权删除该数据")
	}
	return nil
}

type GetProjectDetailReq struct {
	ID int `form:"id"`

	common.ControlBy
}

// GetProjectDetailResp Generated by Apifox
type GetProjectDetailResp struct {
	CalledStatus    *CalledStatus      `json:"calledStatus"`
	QueueStatus     *QueueStatus       `json:"queueStatus"`
	ProcessingOrder *[]ProcessingOrder `json:"processingOrder"`
	ProjectStatus   *ProjectStatus     `json:"projectStatus"`
	Running         bool               `json:"running"`
	SpareSeatC      float64            `json:"spareSeatC"`
	BusySeatC       float64            `json:"busySeatC"`
}

func GetProjectDetail(ctx context.Context, req GetProjectDetailReq) (GetProjectDetailResp, error) {
	var (
		err               error
		projectDetailResp GetProjectDetailResp
	)
	var p = model.Project{}
	err = scrm.GormDB.WithContext(ctx).Where("id = ?", req.ID).First(&p).Error
	if err != nil {
		scrm.Logger().Error("load project (loading project table) database err", err.Error())
		return GetProjectDetailResp{}, err
	}
	projectDetailResp.Running = p.Running
	projectDetailResp.BusySeatC = p.BusySeatC
	projectDetailResp.SpareSeatC = p.SpareSeatC
	projectDetailResp.ProjectStatus, err = LoadProjectStatus(ctx, req.ID)
	if err != nil {
		return GetProjectDetailResp{}, err
	}
	projectDetailResp.QueueStatus, projectDetailResp.ProcessingOrder, err = LoadQueueStatusAndProcessingOrder(ctx, req.ID)
	if err != nil {
		return GetProjectDetailResp{}, err
	}
	projectDetailResp.CalledStatus, err = LoadCalledStatus(ctx, req.ID)
	if err != nil {
		return GetProjectDetailResp{}, err
	}
	return projectDetailResp, nil
}

type GetSeatDetailOfProjectResp struct {
	SeatOfProjectDetail []SeatOfProjectDetail `json:"seatOfProjectDetail"`
	SeatTotal           int                   `json:"seatTotal"`
	CheckinTotal        int64                 `json:"checkinTotal"`
	ReadyTotal          int64                 `json:"readyTotal"`
	SipTotal            int64                 `json:"sipTotal"`
	LockTotal           int64                 `json:"lockTotal"`
	WaitTimeTotal       int64                 `json:"waitTimeTotal"`
	LockNumberTotal     int64                 `json:"lockNumberTotal"`
	CallTimeTotal       int64                 `json:"callTimeTotal"`
}

type SeatOfProjectDetail struct {
	ID          int    `json:"id"`
	SeatName    string `json:"seatName"`
	Line        string `json:"line"`
	ProjectName string `json:"projectName"`
	Checkin     bool   `json:"checkin"`
	Ready       bool   `json:"ready"`
	Sip         bool   `json:"sip"`
	Lock        bool   `json:"lock"`
	WaitTime    int64  `json:"waitTime"`
	LockNumber  int64  `json:"lockNumber"`
	CallTime    int64  `json:"callTime"`
}

func GetSeatDetailOfProject(ctx context.Context, req GetProjectDetailReq) (GetSeatDetailOfProjectResp, error) {
	var (
		p                       model.Project
		seatDetailOfProjectResp GetSeatDetailOfProjectResp
	)
	err := scrm.GormDB.WithContext(ctx).
		Preload("Seats").
		Where("id = ?", req.ID).
		First(&p).Error
	if err != nil {
		scrm.Logger().WithContext(ctx).Error(err.Error())
		return GetSeatDetailOfProjectResp{}, err
	}

	var seatCount []memSeatStatisticDBReceiver
	if err = scrm.GormDB.WithContext(ctx).
		Table("scrm_call c").
		Select("count(*) LockCount,sum(c.seat_call_duration) CallDuration,c.seat_id SeatID").
		Joins("left join scrm_order o on o.id=c.order_id").
		Where("o.project_id = ?", req.ID).
		Where("c.seat_id > 0").
		Where("date(custom_answer_time)=curdate()").
		Group("c.seat_id").
		Scan(&seatCount).Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("database error when searching seat statistic")
		return GetSeatDetailOfProjectResp{}, err
	}
	seatMap := make(map[int]SeatStatisticInfo)
	for _, v := range seatCount {
		seatMap[v.SeatID] = SeatStatisticInfo{
			TotalCallAmount:   v.LockCount,
			TotalCallDuration: v.CallDuration,
		}
	}

	lines := make([]string, 0)
	for _, v := range p.Seats {
		data, err := DefaultSeatHub.seatStateStore.Get(ctx, strconv.Itoa(v.ID))
		if err != nil {
			scrm.Logger().WithContext(ctx).Error(err.Error())
			return GetSeatDetailOfProjectResp{}, err
		}
		var rp model.Project
		if len(data.Projects) != 0 {
			err = scrm.GormDB.WithContext(ctx).Where("id = ?", data.Projects[0]).
				First(&rp).Error
			if err != nil {
				scrm.Logger().WithContext(ctx).Error(err.Error())
				return GetSeatDetailOfProjectResp{}, err
			}
		}

		var lockNumber, callDuration int64
		if seat, ok := seatMap[v.ID]; ok {
			lockNumber, callDuration = seat.TotalCallAmount, seat.TotalCallDuration
		}
		lines = append(lines, v.Line.String)
		seatOfProjectDetail := SeatOfProjectDetail{
			ID:          v.ID,
			SeatName:    v.Nickname,
			Line:        v.Line.String,
			ProjectName: rp.Name,
			Checkin:     data.CheckIn,
			Ready:       data.Ready,
			Sip:         false,
			Lock:        data.Locked,
			LockNumber:  lockNumber,
			CallTime:    callDuration,
		}
		if seatOfProjectDetail.Ready && !seatOfProjectDetail.Lock {
			seatOfProjectDetail.WaitTime = (time.Now().UnixMilli() - data.ReadyTimestamp) / 1000
		}
		seatDetailOfProjectResp.SeatOfProjectDetail = append(seatDetailOfProjectResp.SeatOfProjectDetail, seatOfProjectDetail)
	}
	cmds, err := scrm.CtiRedisClient.Pipelined(ctx, func(pipe redis.Pipeliner) error {
		for _, key := range lines {
			pipe.HExists(ctx, "registrations", key)
		}
		return nil
	})
	if err != nil {
		scrm.Logger().WithContext(ctx).Error(err.Error())
		return GetSeatDetailOfProjectResp{}, err
	}
	for i, v := range cmds {
		seatDetailOfProjectResp.SeatOfProjectDetail[i].Sip = v.(*redis.BoolCmd).Val()
		if seatDetailOfProjectResp.SeatOfProjectDetail[i].Checkin {
			seatDetailOfProjectResp.CheckinTotal++
		}
		if seatDetailOfProjectResp.SeatOfProjectDetail[i].Ready && seatDetailOfProjectResp.SeatOfProjectDetail[i].ProjectName == p.Name {
			seatDetailOfProjectResp.ReadyTotal++
		}
		if seatDetailOfProjectResp.SeatOfProjectDetail[i].Sip {
			seatDetailOfProjectResp.SipTotal++
		}
		if seatDetailOfProjectResp.SeatOfProjectDetail[i].Lock {
			seatDetailOfProjectResp.LockTotal++
		}
		seatDetailOfProjectResp.WaitTimeTotal = seatDetailOfProjectResp.WaitTimeTotal + seatDetailOfProjectResp.SeatOfProjectDetail[i].WaitTime
		seatDetailOfProjectResp.LockNumberTotal = seatDetailOfProjectResp.LockNumberTotal + seatDetailOfProjectResp.SeatOfProjectDetail[i].LockNumber
		seatDetailOfProjectResp.CallTimeTotal = seatDetailOfProjectResp.CallTimeTotal + seatDetailOfProjectResp.SeatOfProjectDetail[i].CallTime
	}
	seatDetailOfProjectResp.SeatTotal = len(p.Seats)
	return seatDetailOfProjectResp, nil
}

type UnlockProjectReq struct {
	SeatID int `json:"seatId"`
}

func UnlockProjectSeat(ctx context.Context, req UnlockProjectReq) error {
	_, err := DefaultSeatHub.seatStateStore.Update(ctx, strconv.Itoa(req.SeatID), func(data *SeatWSEventDataStateChanged) *SeatWSEventDataStateChanged {
		if data.Locked {
			data.Locked = false
			data.CallID = ""
			return data
		}
		return nil
	})
	if err != nil {
		scrm.Logger().WithContext(ctx).Error(err.Error())
		return err
	}
	return nil
}

type CalledStatus struct {
	Answered         int64 `json:"answered"`
	Busy             int64 `json:"busy"`
	Miss             int64 `json:"miss"`
	OtherUnconnected int64 `json:"otherUnconnected"`
	Reject           int64 `json:"reject"`
	VacantPhoneNum   int64 `json:"vacantPhoneNum"`
}

type calledStatusReceiver struct {
	ConnectionCondition string
	Count               int
}

type QueueStatus struct {
	AICalling             int64 `json:"aiCalling"`
	PrepareOrCallingCount int64 `json:"prepareOrCallingCount"`
	SeatCalling           int64 `json:"seatCalling"`
	Transforming          int64 `json:"transforming"`
}

type ProcessingOrder struct {
	OrderID               string `json:"orderId" gorm:"column:orderId"`
	CallID                string `json:"callId" gorm:"column:callId"`
	Phone                 string `json:"phone" gorm:"column:phone"`
	ConnectionCondition   string `json:"connectionCondition" gorm:"column:connectionCondition"`
	ModelLabel            string `json:"modelLabel" gorm:"column:modelLabel"`
	QueueStatus           string `json:"queueStatus" `
	DialUpCustomTime      string `json:"dialUpCustomTime" gorm:"column:dial_up_customTime"`
	AICallDuration        int64  `json:"aiCallDuration" gorm:"column:aiCallDuration"`
	CustomRingingDuration int64  `json:"customRingingDuration" gorm:"column:customRingingDuration"`
	SeatCallDuration      int64  `json:"seatCallDuration" gorm:"column:seatCallDuration"`
	SwitchingDuration     int64  `json:"switchingDuration" gorm:"column:switchingDuration"`
}

type ProjectStatus struct {
	Done       int64 `json:"done"`
	Processing int64 `json:"processing"`
	Waiting    int64 `json:"waiting"`
}

type projectStatusReceiver struct {
	Status string `gorm:"column:status"`
	Count  int    `gorm:"column:count"`
}

func callProcessingStatus(call model.Call, status *QueueStatus) bool {
	if !call.DialUpCustomTime.Valid || !call.CustomAnswerTime.Valid {
		status.PrepareOrCallingCount++
		return true
	}
	if call.CustomAnswerTime.Valid && !call.HangUpTime.Valid && !call.SwitchSeatTime.Valid {
		status.AICalling++
		return false
	}
	if call.SwitchSeatTime.Valid && !call.SeatAnswerTime.Valid && !call.HangUpTime.Valid {
		status.Transforming++
		return false
	}
	if call.SeatAnswerTime.Valid && !call.HangUpTime.Valid {
		status.SeatCalling++
		return false
	}
	return false
}

func LoadProjectStatus(ctx context.Context, id int) (*ProjectStatus, error) {
	projectStatus := ProjectStatus{}
	var psr []projectStatusReceiver
	if err := scrm.GormDB.WithContext(ctx).
		Select("status, count(*) count").
		Table("scrm_order").
		Where("project_id = ?", id).
		Group("status").
		Scan(&psr).Error; err != nil {
		scrm.Logger().Error("load project (loading status) database err", err.Error())
		return nil, err
	}
	for _, v := range psr {
		switch v.Status {
		case "等待中":
			projectStatus.Waiting = int64(v.Count)
		case "处理中":
			projectStatus.Processing = int64(v.Count)
		case "已完成":
			projectStatus.Done = int64(v.Count)
		}
	}
	return &projectStatus, nil
}

func LoadQueueStatusAndProcessingOrder(ctx context.Context, id int) (*QueueStatus, *[]ProcessingOrder, error) {
	queueStatus := QueueStatus{}
	var calls []model.Call
	db := scrm.GormDB.WithContext(ctx).
		Preload("Label").
		Preload("CallLabel").
		Joins("left join scrm_order on scrm_order.id=order_id").
		Where("scrm_order.project_id = ?", id).
		Where("scrm_order.status = ?", OrderStatusProcessing).
		Find(&calls)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("load call history error", err.Error())
		return nil, nil, err
	}
	processingOrder := make([]ProcessingOrder, len(calls))
	for k, call := range calls {
		var connectionCondition, modelLabel string
		if call.CallLabel != nil {
			connectionCondition = call.CallLabel.Name
		}
		if call.Label != nil {
			modelLabel = call.Label.Name
		}

		var status = "接通中"
		dialUp := callProcessingStatus(call, &queueStatus)
		if dialUp {
			status = "呼叫中"
		}
		processingOrder[k] = ProcessingOrder{
			AICallDuration:        call.AICallDuration,
			CallID:                call.ID,
			ConnectionCondition:   connectionCondition,
			ModelLabel:            modelLabel,
			Phone:                 call.Phone,
			OrderID:               fmt.Sprint(call.OrderID),
			DialUpCustomTime:      util.SqlNullTimeToTimeFormat(call.DialUpCustomTime),
			QueueStatus:           status,
			CustomRingingDuration: call.CustomRingingDuration,
			SeatCallDuration:      call.SeatCallDuration,
			SwitchingDuration:     call.SwitchingDuration,
		}
	}
	return &queueStatus, &processingOrder, nil
}

func LoadCalledStatus(ctx context.Context, id int) (*CalledStatus, error) {
	calledStatus := CalledStatus{}
	var csr = make([]calledStatusReceiver, 0)
	err := scrm.GormDB.WithContext(ctx).
		Table("scrm_call c").
		Joins("left join scrm_order o on c.order_id = o.id").
		Joins("left join scrm_label l on c.call_label_id = l.id").
		Select("l.name ConnectionCondition, count(l.name) count").
		Where("o.status = ?", "已完成").
		Where("project_id = ?", id).
		Group("l.name").
		Scan(&csr).Error
	if err != nil {
		scrm.Logger().Error("load project (loading called) database err", err.Error())
		return nil, err
	}
	for _, v := range csr {
		switch v.ConnectionCondition {
		case "接通":
			calledStatus.Answered = int64(v.Count)
		case "占线":
			calledStatus.Busy = int64(v.Count)
		case "拒接":
			calledStatus.Reject = int64(v.Count)
		case "未接":
			calledStatus.Miss = int64(v.Count)
		case "其他未接通":
			calledStatus.OtherUnconnected = int64(v.Count)
		case "空号":
			calledStatus.VacantPhoneNum = int64(v.Count)
		}
	}
	return &calledStatus, nil
}

type RunProjectReq struct {
	Running bool `json:"running"`
	ID      int  `json:"id"`

	common.ControlBy
}

type RunProjectResp struct{}

func RunProject(ctx context.Context, req RunProjectReq) error {
	m := model.Project{}
	db := scrm.GormDB.WithContext(ctx).
		Preload("Seats").
		Scopes(
			actions.DeptPermission(ctx, m.TableName()),
		).Find(&m, req.ID)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("run robot error", err.Error())
		return err
	}
	if db.RowsAffected == 0 {
		return errors.New("无权更新该数据")
	}
	if len(m.Seats) == 0 && req.Running {
		return errors.New("项目无坐席，无法启动")
	}
	var free bool
	for _, v := range m.Seats {
		ss, err := DefaultSeatHub.seatStateStore.Get(ctx, strconv.Itoa(v.ID))
		if err != nil {
			scrm.Logger().WithContext(ctx).Error("get seat state error ", err.Error())
			return err
		}
		if ss.Ready {
			free = true
		}
	}
	if !free && req.Running {
		return errors.New("项目坐席离线，无法启动")
	}
	if m.Running == req.Running {
		return nil
	}

	m.Running = req.Running
	db = scrm.GormDB.WithContext(ctx).
		Select("Running").
		Updates(&m)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("db error", err.Error())
		return err
	}
	return nil
}

type SetProjectSeatsReq struct {
	ID    int   `json:"id"`
	Seats []int `json:"seats"`

	common.ControlBy
}

type SetProjectSeatsResp struct{}

func SetProjectSeats(ctx context.Context, req SetProjectSeatsReq) error {
	m := model.Project{}
	db := scrm.GormDB.WithContext(ctx).
		Scopes(
			actions.DeptPermission(ctx, model.Project{}.TableName()),
		).First(&m, req.ID)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("set seats error", err.Error())
		return err
	}
	if db.RowsAffected == 0 {
		return errors.New("无权更新该数据")
	}

	m.ID = req.ID
	seats := []*model.Seat{}
	for _, v := range req.Seats {
		seats = append(seats, &model.Seat{ID: v})
	}
	err := scrm.GormDB.WithContext(ctx).
		Model(&m).
		Association("Seats").
		Replace(seats)
	if err != nil {
		scrm.Logger().WithContext(ctx).Error("db error", err.Error())
		return err
	}
	return nil
}

type SetProjectRobotsReq struct {
	ID     int   `json:"id"`
	Robots []int `json:"robots"`

	common.ControlBy
}

type SetProjectRobotsResp struct{}

func SetProjectRobots(ctx context.Context, req SetProjectRobotsReq) error {
	m := model.Project{}
	db := scrm.GormDB.WithContext(ctx).
		Scopes(
			actions.DeptPermission(ctx, m.TableName()),
		).First(&m, req.ID)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("set seats error", err.Error())
		return err
	}
	if db.RowsAffected == 0 {
		return errors.New("无权更新该数据")
	}

	var robotID int
	if len(req.Robots) > 0 {
		robotID = req.Robots[0]
	}
	db = scrm.GormDB.WithContext(ctx).
		Model(&m).
		Where("id = ?", req.ID).
		Update("robot_id", robotID)
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error("db error", err.Error())
		return err
	}
	return nil
}

type SetProjectConcurrencyReq struct {
	ID         int     `json:"id"`
	SpareSeatC float64 `json:"spareSeatC"`
	BusySeatC  float64 `json:"busySeatC"`
}

type SetProjectConcurrencyResp struct{}

func SetProjectConcurrency(ctx context.Context, req SetProjectConcurrencyReq) (SetProjectConcurrencyResp, error) {
	db := scrm.GormDB.WithContext(ctx).
		Model(&model.Project{}).
		Where("id=?", req.ID).
		Scopes(actions.DeptPermission(ctx, model.Project{}.TableName())).
		Updates(map[string]interface{}{
			"spare_seat_c": req.SpareSeatC,
			"busy_seat_c":  req.BusySeatC,
		})
	if err := db.Error; err != nil {
		scrm.Logger().WithContext(ctx).Error(err.Error())
		return SetProjectConcurrencyResp{}, nil
	} else if db.RowsAffected == 0 {
		return SetProjectConcurrencyResp{}, errors.New("无权更新数据")
	}
	return SetProjectConcurrencyResp{}, nil
}

type Pagination struct {
	PageIndex int `form:"pageIndex"`
	PageSize  int `form:"pageSize"`
}

func (m *Pagination) GetPageIndex() int {
	if m.PageIndex <= 0 {
		m.PageIndex = 1
	}
	return m.PageIndex
}

func (m *Pagination) GetPageSize() int {
	if m.PageSize <= 0 {
		m.PageSize = 10
	}
	return m.PageSize
}
